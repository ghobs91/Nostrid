@page "/follows"
@implements IDisposable

@using Nostrid.Data;
@using Nostrid.Data.Relays;
@using Nostrid.Interfaces;
@using Nostrid.Model;
@using Nostrid.Misc;
@using System.Collections.Concurrent;
@using Microsoft.AspNetCore.Components.Web.Virtualization;

@inject AccountService accountService
@inject RelayService relayService
@inject FeedService feedService

@code
{
    [CascadingParameter]
    public Alert? Alert { get; set; }
}

<div class="alert alert-light m-0" role="alert">
    These are your current and previous follows. Source data is what is stored in your local
    database and what is reported by relays.
    If there are missing follows then try connecting to other relays.
    Your follows are NOT changed unless you press the UPDATE button.
</div>

<div style="margin-bottom: -1rem;" class="mx--3">
    <div class="sticky-top border-bottom d-flex flex-row p-3 bg-body">
        <div class="d-flex flex-row flex-grow-1 align-items-center flex-wrap">
            <div class="btn-group me-3 mb-1">
                <button class="btn btn-outline-secondary" @onclick="OpenImportModal">Import</button>
                @*<button class="btn btn-outline-secondary">Export</button>*@
            </div>
            <button class="btn btn-primary me-3 mb-1" @onclick="Update" disabled="@loading">
                @if (loading)
                {
                    <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                    <span>Updating...</span>
                }
                else
                {
                    <span>Update</span>
                }
            </button>
            <div class="fs-7">
                <span>@(follows?.Values.Count(f => f.Selected)) will be followed.</span>
                <span>@(follows?.Values.Count(f => !f.Selected)) will not be followed.</span>
            </div>
        </div>
        <div class="d-flex flex-column align-items-end">
            <label role="button" for="selectAll" class="fs-7 text-nowrap">@(SelectAll ? "Unselect" : "Select") All</label>
            <div class="form-check m-0">
                <InputCheckbox id="selectAll" @bind-Value="SelectAll" class="form-check-input" style="width: 20px; height: 20px;" />
            </div>
        </div>
    </div>
    <Virtualize Context="follow" Items="follows?.Values">
        <FollowAccount AccountId="@follow.AccountId" Selectable="true" @bind-Selected="follow.Selected">
            <span class="fw-bold">@(follow.EventTime.HasValue ? follow.EventTime : "Imported")</span>
        </FollowAccount>
    </Virtualize>
</div>

<ModalContainer @ref="importModal">
    <div class="modal fade" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-fullscreen-sm-down modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h1 class="modal-title fs-5" id="exampleModalLabel">Import</h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body p-0 d-flex">
                    <InputTextArea class="form-control rounded-0 border-0 glow-0" style="resize: none;" rows="10"
                                   placeholder="Paste one npub or hex per line" @bind-Value="importText">
                    </InputTextArea>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary" @onclick="Import">Import</button>
                </div>
            </div>
        </div>
    </div>
</ModalContainer>

@code {
    private ConcurrentDictionary<string, Follow>? follows;
    private SubscriptionFilter? filter;
    private ModalContainer? importModal;
    private string importText;
    private bool selectAll;
    private bool SelectAll
    {
        get => selectAll;
        set
        {
            selectAll = value;
            ToggleAll(value);
        }
    }
    private UpdatabableElement? updateButton;
    private bool loading;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        if (accountService.MainAccount == null)
        {
            return;
        }

        follows = new();
        filter = new PastFollowsSubscriptionFilter(accountService.MainAccount.Id)
        {
            DontSaveInLocalCache = true,
            Handler = ReceivedEvents,
        };
        relayService.AddFilters(filter);
        ReceivedEvents(feedService.GetNotesFeed(filter, int.MaxValue));
    }

    private void OpenImportModal()
    {
        importModal?.Show();
    }

    private void Import()
    {
        var followsToImport = importText.Split(
            new string[] { Environment.NewLine, "\n" },
            StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);

        foreach (var follow in followsToImport)
        {
            var hex = ByteTools.Bech32ToHex(follow, "npub") ?? follow;
            if (Utils.IsValidNostrId(hex) 
                && follows.TryAdd(hex, new Follow(hex, null, accountService.IsFollowing(hex))))
            {
                accountService.AddDetailsNeeded(hex);
            }
        }

        importModal?.Hide();
        importText = string.Empty;
    }

    private async Task Update()
    {
        var selectedAccountIds = follows?.Values.Where(follow => follow.Selected).Select(follow => follow.AccountId).ToList();
        if (selectedAccountIds == null) return;
        loading = true;
        try
        {
            await accountService.SetFollows(selectedAccountIds);
            Alert?.Show("Follows has been saved", Alert.Type.Success);
        }
        catch
        {
            Alert?.Show("Error updating follows", Alert.Type.Danger);
        }
        finally
        {
            loading = false;
        }
    }

    private void ToggleAll(bool value)
    {
        follows?.Values.ToList().ForEach(follow => follow.Selected = value);
    }

    private void ReceivedEvents(IEnumerable<Event> events)
    {
        foreach (var ev in events)
        {
            var newFollows = accountService.GetFollowsFromEvent(ev);
            MergeContacts(newFollows, ev.CreatedAt ?? DateTimeOffset.MinValue);
        }
        InvokeAsync(() => StateHasChanged());
    }

    private void MergeContacts(IEnumerable<string> newFollows, DateTimeOffset eventTime)
    {
        foreach (var follow in newFollows)
        {
            follows?.AddOrUpdate(
                follow,
                new Follow(follow, eventTime, accountService.IsFollowing(follow)),
                (_, oldv) => oldv.EventTime > eventTime ? oldv : new Follow(follow, eventTime, accountService.IsFollowing(follow)));
            accountService.AddDetailsNeeded(follow);
        }
    }

    private class Follow
    {
        public string AccountId { get; set; }
        public DateTimeOffset? EventTime { get; set; }
        public bool Selected { get; set; }

        public Follow(string accountId, DateTimeOffset? eventTime, bool selected)
        {
            AccountId = accountId;
            EventTime = eventTime;
            Selected = selected;
        }
    }

    #region Dispose
    private bool _disposed;

    public void Dispose() => Dispose(true);

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                Cleanup();
            }

            _disposed = true;
        }
    }

    private void Cleanup()
    {
        if (filter != null)
        {
            relayService.DeleteFilters(filter);
        }
    }
    #endregion
}
