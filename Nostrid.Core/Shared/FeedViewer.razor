@using Nostrid.Data
@using Nostrid.Data.Relays;
@using Nostrid.Model;
@using Nostrid.Misc;
@using System.Collections.Concurrent;
@inject FeedService feedService
@inject RelayService relayService
@inject AccountService accountService
@implements IDisposable

@code {
    [Parameter, EditorRequired]
    public SubscriptionFilter BaseFilter { get; set; } = null!;

    [Parameter, EditorRequired]
    public int[] MessageKinds { get; set; }

    [Parameter]
    public string? ChannelId { get; set; }
}

<UpdatabableElement @ref="@labelShowNewPosts">
    <Content>
        @if (newN.Count > 0)
        {
            <div class="text-center px-3 @(!inChannel ? "border-top" : "")" style="margin: 0 -1rem;">
                <button class="btn btn-link btn-sm mx-3 my-2" type="button" @onclick="ShowNewPosts">Show @newN.Count new posts</button>
            </div>
        }
    </Content>
</UpdatabableElement>
@if (renderedN.Count == 0)
{
    <div class="text-center px-3 py-2 @(!inChannel ? "border-top" : "")" style="margin: 0 -1rem;">
        <div class="spinner-border mx-3 my-2" role="status">
            <span class="visually-hidden">Waiting for feed...</span>
        </div>
    </div>
}
else
{
    var trees = inChannel ? feedService.GetTreesFromNotesNoGrouping(renderedN.Values) : feedService.GetTreesFromNotes(renderedN.Values);
    // Root nodes are sorted newest on top
    trees.Sort((a, b) => b.Note.CreatedAtCurated.CompareTo(a.Note.CreatedAtCurated));

    <NoteTreeViewer @ref="noteTreeViewer" Trees="@trees" ShowAsMessage="@inChannel" />
    <div class="text-center @(!inChannel ? "border-top" : "") px-3" style="margin: 0 -1rem;">
        <button class="btn btn-link btn-sm mx-3 my-2" type="button" @onclick="@LoadMore">Load more</button>
    </div>   
}

<div class="position-absolute" style="height: 44px; width: 44px; @(!inChannel ? "bottom" : "top"): 1rem; right: 1rem;">
    <div class="position-fixed">
        <UpdatabableElement @ref="@labelLoadMore">
            <Content>
                <button disabled="@requestDisabled" @onclick="@(async () => await LoadMoreFromNoteAsync())" type="button" class="btn btn-secondary rounded-5 shadow fs-4">
                    <i class="bi bi-arrow-repeat"></i>
                </button>
            </Content>
        </UpdatabableElement>
    </div>
</div>

@code {
    private bool inChannel => !ChannelId.IsNullOrEmpty();
    private ConcurrentDictionary<string, Event> renderedN = new(), newN = new(), oldN = new();
    private int dbLimit;
    private SubscriptionFilter? newFilter, oldFilter;
    private string[]? renderedIds;
    private NoteTreeViewer? noteTreeViewer;
    private bool requestDisabled;
    private UpdatabableElement? labelShowNewPosts, labelLoadMore;

    private const int RelayQueryLimit = 13;
    private const int SecondsForDetailsFilters = 30;

    private void ShowNewPosts()
    {
        EventExtension.MergeAndClear(renderedN, newN);
        TrimOlder();
    }

    private void LoadMore()
    {
        dbLimit += RelayQueryLimit;
        EventExtension.Merge(renderedN, feedService.GetNotesFeed(BaseFilter, dbLimit, MessageKinds));
    }

    private async Task LoadMoreFromNoteAsync()
    {
        if (noteTreeViewer == null)
        {
            return;
        }
        var treeItem = await noteTreeViewer.GetFirstVisibleAsync();
        if (treeItem == null)
        {
            return;
        }

        oldFilter.LimitFilterData.Until = DateTimeOffset.FromUnixTimeSeconds(treeItem.Tree.Note.CreatedAtCurated);
        relayService.RefreshFilters(oldFilter);

        requestDisabled = true;

        _ = Task.Delay(5000).ContinueWith((_) =>
        {
            requestDisabled = false;
            labelLoadMore?.Update();
        });
    }

    private void ReceivedNotes(object? sender, (string filterId, IEnumerable<Event> notes) data)
    {
        if (_disposed || renderedN == null || renderedIds == null || (data.filterId != oldFilter.Id && data.filterId != newFilter.Id))
            return;

        var notes = data.notes.Where(n => MessageKinds.Contains(n.Kind));
        if (!notes.Any())
            return;

        if (inChannel)
        {
            EventExtension.Merge(renderedN, notes);
            TrimOlder();
            InvokeAsync(() => StateHasChanged());
        }
        else if (data.filterId == oldFilter.Id)
        {
            EventExtension.Merge(renderedN, notes);
            TrimOlder();
        }
        else
        {
            EventExtension.Merge(newN, notes);
            labelShowNewPosts?.Update();
        }
    }

    protected override void OnParametersSet()
    {
        Cleanup();

        renderedN = new();
        newN = new();
        oldN = new();
        renderedIds = new string[0];

        newFilter = BaseFilter.Clone();
        oldFilter = BaseFilter.Clone();
        oldFilter.LimitFilterData.Limit = RelayQueryLimit;
        oldFilter.LimitFilterData.Until = DateTimeOffset.UtcNow;
        newFilter.LimitFilterData.Limit = 1;
        dbLimit = 0;

        relayService.AddFilters(newFilter, oldFilter);

        LoadMore();

        feedService.NotesReceived += ReceivedNotes;
        feedService.NoteReceivedChild += NoteReceivedChild;
    }

    private void NoteReceivedChild(object? sender, (string EventId, Event Child) data)
    {
        if (!renderedN.ContainsKey(data.EventId))
            return;

        renderedN[data.Child.Id] = data.Child;
        TrimOlder();
        InvokeAsync(() => StateHasChanged());
    }

    private void TrimOlder()
    {
        if (renderedN == null || renderedN.Count <= dbLimit)
        {
            return;
        }

        if (renderedN.Count > dbLimit * 2)
        {
            // Better to create a new list
            renderedN = new(renderedN.OrderByDescending(n => n.Value.CreatedAtCurated).Take(dbLimit));
        }
        else
        {
            // Better to remove older items
            var toRemove = renderedN.Values.OrderByDescending(n => n.CreatedAtCurated).Select(n => n.Id).Skip(dbLimit).ToList();
            foreach (var item in toRemove)
            {
                renderedN.TryRemove(item, out _);
            }
        }
    }

    #region Dispose
    private bool _disposed;

    public void Dispose() => Dispose(true);

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                Cleanup();
            }

            _disposed = true;
        }
    }

    private void Cleanup()
    {
        feedService.NotesReceived -= ReceivedNotes;
        feedService.NoteReceivedChild -= NoteReceivedChild;
        relayService.DeleteFilters(newFilter, oldFilter);
    }
    #endregion

}
